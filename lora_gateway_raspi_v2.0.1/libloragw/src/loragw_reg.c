/*
 / _____)             _              | |
( (____  _____ ____ _| |_ _____  ____| |__
 \____ \| ___ |    (_   _) ___ |/ ___)  _ \
 _____) ) ____| | | || |_| ____( (___| | | |
(______/|_____)_|_|_| \__)_____)\____)_| |_|
  (C)2013 Semtech-Cycleo

Description:
	Functions used to handle a single LoRa LINCENTRATOR.
	Registers are addressed by name.
	Multi-bytes registers are handled automatically.
	Read-modify-write is handled automatically.

License: Revised BSD License, see LICENSE.TXT file include in the project
Maintainer: Sylvain Miermont


Modified by linjinzhi <jz.lin@siat.ac.cn>
*/


/* -------------------------------------------------------------------------- */
/* --- DEPENDANCIES --------------------------------------------------------- */

#include <stdint.h>		/* C99 types */
#include <stdbool.h>	/* bool type */
#include <stdio.h>		/* printf fprintf */

#include "loragw_spi.h"
#include "loragw_reg.h"

#include <wiringPi.h>

/* -------------------------------------------------------------------------- */
/* --- PRIVATE MACROS ------------------------------------------------------- */

#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
#if DEBUG_REG == 1
	#define DEBUG_MSG(str)				fprintf(stderr, str)
	#define DEBUG_PRINTF(fmt, args...)	fprintf(stderr,"%s:%d: "fmt, __FUNCTION__, __LINE__, args)
	#define CHECK_NULL(a)				if(a==NULL){fprintf(stderr,"%s:%d: ERROR: NULL POINTER AS ARGUMENT\n", __FUNCTION__, __LINE__);return LGW_REG_ERROR;}
#else
	#define DEBUG_MSG(str)
	#define DEBUG_PRINTF(fmt, args...)
	#define CHECK_NULL(a)				if(a==NULL){return LGW_REG_ERROR;}
#endif

/* -------------------------------------------------------------------------- */
/* --- PRIVATE TYPES -------------------------------------------------------- */

struct lgw_reg_s {
	int8_t		page;		/*!< page containing the register (-1 for all pages) */
	uint8_t		addr;		/*!< base address of the register (7 bit) */
	uint8_t		offs;		/*!< position of the register LSB (between 0 to 7) */
	bool		sign;		/*!< 1 indicates the register is signed (2 complem.) */
	uint8_t		leng;		/*!< number of bits in the register */
	bool		rdon;		/*!< 1 indicates a read-only register */
	int32_t		dflt;		/*!< register default value */
};

/* -------------------------------------------------------------------------- */
/* --- PRIVATE CONSTANTS ---------------------------------------------------- */

#define PAGE_ADDR		0x00
#define PAGE_MASK		0x03

#define FPGA_VERSION    18

/*
auto generated register mapping for C code : 11-Jul-2013 13:20:40
this file contains autogenerated C struct used to access the LoRa register from the Primer firmware
this file is autogenerated from registers description
293 registers are defined
*/
// TODO: to be modified according to SX127x
const struct lgw_reg_s loregs[LGW_TOTALREGS] = {
};

/* -------------------------------------------------------------------------- */
/* --- PRIVATE VARIABLES ---------------------------------------------------- */

void *lgw_spi_target = NULL; /*! generic pointer to the SPI device */
static uint8_t lgw_spi_mux_mode = 2; /*! current SPI mux mode used */

/* -------------------------------------------------------------------------- */
/* --- PRIVATE FUNCTIONS ---------------------------------------------------- */


/* -------------------------------------------------------------------------- */
/* --- PUBLIC FUNCTIONS DEFINITION ------------------------------------------ */

/* Concentrator connect */
int lgw_connect(void) {
    int spi_stat = LGW_SPI_SUCCESS;

    if (lgw_spi_target != NULL) {
        DEBUG_MSG("WARNING: LINCENTRATOR was already connected\n");
        lgw_spi_close(lgw_spi_target);
    }
    // open the SPI link
    spi_stat = lgw_spi_open(&lgw_spi_target);
    if (spi_stat != LGW_SPI_SUCCESS) {
        DEBUG_MSG("ERROR: Failed to connect to LINCENTRATOR.\n");
        return LGW_REG_ERROR;
    }

/*    if(wiringPiSPISetup(0, 10000000) < 0) {
    	DEBUG_MSG("ERROR CONNECTING LINCENTRATOR\n");
    	return LGW_REG_ERROR;
    }
*/
    lgw_spi_mux_mode = LGW_SPI_MUX_MODE2; // we are using ourself's solution, not the same as SX1301 concentrator

    DEBUG_MSG("NOTE: Connected to LINCENTRATOR.\n");
    return LGW_REG_SUCCESS;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* Concentrator disconnect */
int lgw_disconnect(void) {
	if (lgw_spi_target != NULL) {
		lgw_spi_close(lgw_spi_target);
		lgw_spi_target = NULL;
		DEBUG_MSG("Note: success disconnecting the LINCENTRATOR\n");
		return LGW_REG_SUCCESS;
	} else {
		DEBUG_MSG("WARNING: LINCENTRATOR was already disconnected\n");
		return LGW_REG_ERROR;
	}
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* reset function */
int lgw_soft_reset(void) {
	/* check if SPI is initialised */
	if ((lgw_spi_target == NULL)) {
		DEBUG_MSG("ERROR: LINCENTRATOR UNCONNECTED\n");
		return LGW_REG_ERROR;
	}
	// TODO: How to softly reset LINCENTRATOR?
	return LGW_REG_SUCCESS;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* register verification */
// TODO: to implement this function
int lgw_reg_check(FILE *f) {
	/*
	struct lgw_reg_s r;
	int32_t read_value;
	char ok_msg[] = "+++MATCH+++";
	char notok_msg[] = "###MISMATCH###";
	char *ptr;
	int i;
	
	// check if SPI is initialised
	if ((lgw_spi_target == NULL)) {
		DEBUG_MSG("ERROR: LINCENTRATOR UNCONNECTED\n");
		fprintf(f, "ERROR: LINCENTRATOR UNCONNECTED\n");
		return LGW_REG_ERROR;
	}
	
	fprintf(f, "Start of register verification\n");
	for (i=0; i<LGW_TOTALREGS; ++i) {
		r = loregs[i];
		lgw_reg_r(i, &read_value);
		ptr = (read_value == r.dflt) ? ok_msg : notok_msg;
		if (r.sign == true)
			fprintf(f, "%s reg number %d read: %d (%x) default: %d (%x)\n", ptr, i, read_value, read_value, r.dflt, r.dflt);
		else
			fprintf(f, "%s reg number %d read: %u (%x) default: %u (%x)\n", ptr, i, read_value, read_value, r.dflt, r.dflt);
	}
	fprintf(f, "End of register verification\n");
	*/
	if(f == NULL)
		return LGW_REG_ERROR;
	else
		return LGW_REG_SUCCESS;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


int lgw_reg_w(uint8_t target_chip, uint8_t register_id, uint8_t reg_value) {
	return lgw_spi_w(lgw_spi_target, lgw_spi_mux_mode, target_chip, (uint8_t)register_id, (uint8_t)reg_value);
}

int lgw_reg_r(uint8_t target_chip, uint8_t register_id, uint8_t *reg_value) {
	return lgw_spi_r(lgw_spi_target, lgw_spi_mux_mode, target_chip, (uint8_t)register_id, reg_value);
}

int lgw_reg_wb(uint8_t target_chip, uint8_t register_id, uint8_t *data, uint8_t size) {
	return lgw_spi_wb(lgw_spi_target, lgw_spi_mux_mode, target_chip, (uint8_t)register_id, data, size);
}

int lgw_reg_rb(uint8_t target_chip, uint8_t register_id, uint8_t *data, uint8_t size) {
	return lgw_spi_rb(lgw_spi_target, lgw_spi_mux_mode, target_chip, (uint8_t)register_id, data, size);
}

/* --- EOF ------------------------------------------------------------------ */
